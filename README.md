# SokolovskaBot

Користувач спочатку повинен створити свого улюбленця, він пише команду /create. Оновлення приходить до класу Bot у метод onUpdateReceived, потім PetControllerFactory створює новий PetCreator в методі getPetController, під час створення PetCreator відправляє повідомлення з кнопками в чат, даючи можливість обрати тип тварини. Якщо користувач пише повідомлення, коли треба натиснути кнопку, у чаті, за допомогою ExceptionMaster, з'являється сповіщення про неправильний ввід (воно зникне, коли введення буде правильним). Далі, коли користувач натискає кнопку, клас Bot передає це оновлення до PetControllerFactory, а той по черзі, у методі workWithController(), за допомогою пулу потоків, створює новий потік, який викличе метод інтерфейсу PetController execute(), з усією логікою PetCreator'a.
PetCreator спочатку оновить час останньої взаємодії з користувачем, так як в класі PetControllerFactory ініціалізовано екземпляр класу PetControllerListener, який потрібен для регулярної перевірки пустуючих PetController, які в подальшому видаляються. Далі він перевіряє оновлення на помилки (наприклад, замість очікуваного натискання кнопки, користувач відправив повідомлення), проводить приховані від користувача процеси, і після цього відправляє відповідне повідомлення з подальшим налаштуванням.
Таким чином, користувач створює свого улюбленця, пройшовши 4 пункти: вказавши тип тварини, відправивши фото улюбленця, вказавши ім'я улюбленця, та встановивши початкову вагу.
Після цього для нього відкривається нова можливість – тепер він може нагодувати свого улюбленця. Для цього він вводить команду /feed, яка приходить до класу Bot, де він виконує ті ж операції, але тепер вже з іншою реалізацією класу PetController – EatController. В результаті користувачу випадає список всіх його улюбленців, і після вибору одного з них, йому відправляється повідомлення з кнопками 3 випадкових емодзі тварин. Користувач повинен обрати одну з тварин як їжу для свого улюбленця (в якого вже на стадії створення були сформовані випадкові уподобання в їжі), і після цього побачити, чи сподобалося те, що він обрав, його звірятку, чи ні. Та, у свою чергу, буде рости, або, навпаки, худнути.

Про ООП:

Інкапсуляція: Застосовується завдяки приватним змінним, доступ до яких реалізується за допомогою методів геттерів та сеттерів. Це дозволяє захистити внутрішнє представлення об'єкта від зовнішнього втручання і контролювати доступ до цих змінних.
Наслідування: Цей принцип видно завдяки класу Pet, який є базовим (абстрактним) класом. Інші класи, такі як Cat, Dog та Parrot, успадковують його властивості та методи. Це дозволяє уникнути дублювання коду, реалізуючи загальні характеристики в базовому класі.
Абстракція: Ілюструється абстрактним класом Pet, який визначає загальний набір характеристик та методів для своїх нащадків, але при цьому не може мати власних екземплярів. Це дає можливість моделювати загальний шаблон для ряда пов'язаних об'єктів.
Поліморфізм: Явно демонструється через інтерфейс PetController, який може мати декілька реалізацій (наприклад, PetCreator та EatController). Завдяки цьому, можна використовувати об'єкти різних класів через спільний інтерфейс, що дозволяє писати більш гнучкий та зрозумілий код.
